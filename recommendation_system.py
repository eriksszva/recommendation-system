# -*- coding: utf-8 -*-
"""recommendation_system.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1spdPHh-SnpCjqYGriXzxw8P99j3wF0tj

# Download Dataset
"""

# get data
!wget -O ml-latest-small.zip https://files.grouplens.org/datasets/movielens/ml-latest-small.zip

# unzip file
!unzip ml-latest-small.zip

"""# Import Libraries"""

!pip install lightfm

# import libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from wordcloud import WordCloud
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.metrics.pairwise import cosine_similarity
from scipy.sparse import coo_matrix
from lightfm import LightFM
from lightfm.evaluation import precision_at_k, auc_score

"""# Data Understanding

## ðŸ“Š Summary of MovieLens Small (Latest Version) Dataset

**Dataset**: [MovieLens Small Latest Dataset on Kaggle](https://www.kaggle.com/datasets/shubhammehta21/movie-lens-small-latest-dataset)

---

## ðŸŽ¬ Struktur File `movies.csv`

| Kolom   | Tipe Data | Deskripsi                                                                 | Contoh                        |
|---------|-----------|---------------------------------------------------------------------------|-------------------------------|
| movieId | Integer   | ID unik untuk setiap film, konsisten di seluruh file (ratings, tags, links, movies). | 1                             |
| title   | String    | Judul film, termasuk tahun rilis dalam tanda kurung.                      | Toy Story (1995)             |
| genres  | String    | Daftar genre film, dipisahkan oleh simbol pipe. | Adventure\|Animation\|Children |

### ðŸŽ­ Daftar Genre yang Tersedia:
`Action`, `Adventure`, `Animation`, `Children's`, `Comedy`, `Crime`, `Documentary`, `Drama`, `Fantasy`, `Film-Noir`, `Horror`, `Musical`, `Mystery`, `Romance`, `Sci-Fi`, `Thriller`, `War`, `Western`, `(no genres listed)`

---

## â­ Struktur File `ratings.csv`

| Kolom     | Tipe Data | Deskripsi                                                                                     | Contoh     |
|-----------|-----------|-----------------------------------------------------------------------------------------------|------------|
| userId    | Integer   | ID unik dari pengguna yang memberikan rating. Konsisten dengan tags.csv.                      | 10         |
| movieId   | Integer   | ID film yang diberi rating (terhubung ke movies.csv).                                         | 1          |
| rating    | Float     | Nilai rating dari 0.5 hingga 5.0 dalam kelipatan 0.5.                                         | 4.0        |
| timestamp | Integer   | Waktu dalam format Unix timestamp (detik sejak 1 Januari 1970 UTC).                          | 964982703  |

ðŸ“Œ **Catatan**:
- File ini diurut berdasarkan `userId`, lalu `movieId`.
- Setiap baris mewakili satu interaksi rating satu film oleh satu pengguna.

---

## ðŸ·ï¸ Struktur File `tags.csv`

| Kolom     | Tipe Data | Deskripsi                                                                                     | Contoh     |
|-----------|-----------|-----------------------------------------------------------------------------------------------|------------|
| userId    | Integer   | ID pengguna yang memberikan tag. Konsisten dengan ratings.csv.                                | 10         |
| movieId   | Integer   | ID film yang diberi tag. Konsisten dengan file lain.                                          | 1          |
| tag       | String    | Teks tag pendek yang dibuat pengguna, biasanya 1 kata/frase pendek.                           | Pixar      |
| timestamp | Integer   | Waktu penandaan dalam format Unix timestamp.                                                  | 1443148531 |

ðŸ“Œ **Catatan**:
- Baris diurut berdasarkan `userId`, lalu `movieId`.
- Tag bersifat bebas dan ditentukan oleh interpretasi pengguna.

---

## ðŸ”— Struktur File `links.csv`

| Kolom   | Tipe Data | Deskripsi                                                                                         | Contoh       |
|---------|-----------|---------------------------------------------------------------------------------------------------|--------------|
| movieId | Integer   | ID film (sama dengan yang ada di file lainnya, misalnya movies.csv).                              | 1            |
| imdbId  | String    | ID film pada situs IMDb. Format: 7 digit, dapat digunakan di URL: `https://imdb.com/title/tt[imdbId]`. | tt0114709    |
| tmdbId  | Integer   | ID film pada The Movie Database (TMDb), digunakan untuk mengakses data di themoviedb.org.         | 862          |

---
"""

movies = pd.read_csv('ml-latest-small/movies.csv')
ratings = pd.read_csv('ml-latest-small/ratings.csv')
links = pd.read_csv('ml-latest-small/links.csv')
tags = pd.read_csv('ml-latest-small/tags.csv')

print('Jumlah data film: ', len(movies))
print('Jumlah data rating: ', len(ratings))
print('Jumlah data links: ', len(links))
print('Jumlah data tags', len(tags))

"""## Univariate Analysis

### movies variable

#### Melakukan pengecekan tipe data dan banyak kolom
"""

movies.info()

"""**Insight:**

* Berdasarkan hasil pengecekan maka dapat diketahui `movieId` bertipe data `int64`, `title` dan `genres` bertipe `object`. Serta tercatat terdapat 3 kolom dalam variabel ini.

#### Melakukan pengecekan 5 data pertama
"""

movies.head()

"""**Insight**:

* Berdasarkan preview 5 data pertama, tidak terlihat adanya duplikat data.

#### Melakukan pengecekan unique data dalam judul dan genre
"""

print('Banyak judul film: ', movies.title.nunique())
print('Banyak genre film: ', movies.genres.nunique())

"""**Insight**:

* Terdapat sebanyak 9737 judul film dan genre film sebanyak 951

#### Melihat summary statistics data
"""

movies.describe(include='all')

"""**Insight**:

* Total movie id terdapat sebanyak 9742 data, dengan nilai id terkecil 1 dan max adalah 193609. Terdapat 9742 data title dan genre yang tercatat.

#### Melakukan pengecekan missing values dan duplikat
"""

movies.isna().sum()

movies.duplicated().sum()

"""**Insight**:

* Tidak terdapat missing values dan juga duplikat dalam variabel movies

#### Memvisualisasikan top 5 genre
"""

genres_split = movies.genres.str.split('|').explode()
genre_counts = genres_split.value_counts().head(5)
colors = ['skyblue' if count == genre_counts.max() else 'gray' for count in genre_counts]
plt.figure(figsize=(8, 5))
bars = plt.bar(genre_counts.index, genre_counts.values, color=colors)
plt.title('Top 5 Genre')
plt.xlabel('Genre')
plt.ylabel('Count')
plt.tight_layout()
plt.show()

"""**Insight**:

* Top 5 genre yang tercatat adalah drama, comedy, thriller, action, dan romance. Di mana kategori drama mendominasi sebanyak lebih dari 4000 data, lalu diikuti comedy yang tercatat melebihi 3000, lalu diikuti dengan genre thriller yang tercatat hampir sebanyak 2000 data.

#### Memvisualisasikan genre wordcloud
"""

def wordcloud(data, title):
    wc = WordCloud(width=800, height=400, max_words=200, background_color='white').generate(' '.join(data))
    plt.figure(figsize=(10, 8))
    plt.imshow(wc, interpolation='bilinear')
    plt.axis('off')
    plt.title(title)
    plt.show()

wordcloud(genres_split, 'Genres WordCloud')

"""**Insight**:

* Wordcloud menyajikan kata (genre) dengan ukuran yang proporsional terhadap frekuensi kemunculannya, sehingga secara visual mudah mengidentifikasi genre mana yang dominan dan mana yang jarang muncul, seperti genre drama, comedy sering muncul dan genre action jarang muncul.

### ratings variable

#### Melakukan pengecekan tipe data dan banyak kolom
"""

ratings.info()

"""**Insight**:

* Berdasarkan hasil pengecekan maka dapat diketahui movieId, userId, dan timestamp bertipe int64, lalu rating bertipe float64. Serta tercatat terdapat 4 kolom dalam variabel ini.

#### Melakukan pengecekan 5 data pertama
"""

ratings.head()

"""**Insight**:

* Dari 5 data pertama yang ditampilkan terlihat bahwa satu user mampu menonton dan memberikan rating lebih dari 1 film.

#### Melakukan pengecekan macam-macam rating dan jumlahnya
"""

print('Tipe rating film:\n', ratings.rating.unique())
print('\nBanyak tipe rating film:\n', ratings.rating.nunique())

"""**Insight**

* Tercatat rating film memiliki 10 macam tipe rating, yaitu: 4.0, 5.0, 3.0, 2.0, 1.0, 4.5, 3.5, 2.5, 0.5, dan 1.5.

#### Melihat summary statistics
"""

ratings.describe(include='all')

"""**Insights**:

* Terdapat 100836 data dalam userId, dengan nilai minimal 1 dan maksimal 610.
* Terdapat 100836 data dalam movieId, dengan nilai minimal 1 dan max 193609.
* Terdapat 100836 data dalam rating, dengan nilai minimal 0.5 dan max 5.
* Terdapat 100836 data dalam timestamp, timestamp masih belum dalam format yang benar dan perlu diubah.

#### Melakukan pengecekan missing values dan duplikat
"""

ratings.isna().sum()

ratings.duplicated().sum()

"""**Insight**:

* Tidak terdapat missing values dan duplikat yang tercatat.

#### Memvisualisasikan distribusi rating pengguna
"""

rating_counts = ratings['rating'].value_counts().sort_index()
colors = ['skyblue' if count == rating_counts.max() else 'gray' for count in rating_counts]
plt.figure(figsize=(8, 5))
plt.bar(rating_counts.index.astype(str), rating_counts.values, color=colors)
plt.title('Distribusi Rating Pengguna')
plt.xlabel('Rating')
plt.ylabel('Count')
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

"""**Insight**:

* Visualisasi distribusi rating dengan barchart menunjukkan bagaimana pengguna memberikan penilaian terhadap film, dari skala 0.5 hingga 5.0. Dari grafik ini, kita bisa melihat kecenderungan bahwa pengguna lebih sering memberi rating tinggi seperti 3.0, 4.0, dan 5.0 dibanding rating rendah. Hal ini menunjukkan kualitas konten yang disukai pengguna relatif tinggi.

### tags variable

#### Melakukan pengecekan tipe data dan banyak kolom
"""

tags.info()

"""**Insight**:

* Berdasarkan hasil pengecekan maka dapat diketahui movieId, userId, dan timestamp bertipe data int64, tag bertipe object. Serta tercatat terdapat 4 kolom dalam variabel ini.

#### Melakukan pengecekan 5 data pertama
"""

tags.head()

"""**Insight**:

* Dari 5 bari pertama, tidak terlihat adanya duplikat values atau data.

#### Melakukan pengecekan macam-macam tag film dan jumlahnya
"""

print('Tipe tags film:\n', tags.tag.unique())
print('\nBanyaknya tipe tags film:\n', tags.tag.nunique())

"""**Insight**:

* Terdapat 1589 unique tags yang tercatat, seperti funny, gun fu, dan will ferrell.

#### Melihat summary statistics
"""

tags.describe(include='all')

"""**Insights**:

* Terdapat 3683 data userId yang tercatat, dengan userId terkecil 2 dan terbesar 610.
* Terdapat 3683 data movieId yang tercatat, dengan nilai terkecil 1 dan max 193565.
* Terdapat 3683 data tag yang tercatat, dengan nilai unique 1589.
* Terdapat 3683 data timestamp yang tercatat, tetapi formatnya masih salah.

#### Melakukan pengecekan missing values dan duplikat
"""

tags.isna().sum()

tags.duplicated().sum()

"""**Insight**:

* Tidak terdapat missing values maupun data duplikat yang tercatat.

#### Memvisualisasikan tags wordcloud
"""

wordcloud(tags.tag, 'Tags WordCloud')

"""**Insight**:

* Visualisasi tags wordcloud memberikan gambaran tentang istilah atau kata kunci yang sering digunakan oleh pengguna dalam memberikan tag ke film. Ini memperlihatkan minat atau asosiasi populer yang dimiliki pengguna terhadap film tertentu, misalnya â€œNetflixâ€, â€œthrillerâ€, atau â€œclassicâ€.

#### Memvisualisasikan top 5 tag
"""

tag_counts = tags.tag.value_counts().head(5)
colors = ['skyblue' if count == tag_counts.max() else 'gray' for count in tag_counts]
plt.figure(figsize=(8, 5))
bars = plt.bar(tag_counts.index, tag_counts.values, color=colors)
plt.title('Top 5 Tag')
plt.xlabel('Tag')
plt.ylabel('Count')
plt.tight_layout()
plt.show()

"""**Insight**:

* top 5 tags dalam bentuk barchart menunjukkan tag spesifik yang paling sering digunakan pengguna, yaitu "In Netflix Queue", "atmospheric". Berbeda dari wordcloud yang bersifat eksploratif, barchart memberikan informasi kuantitatif yang lebih jelas dan terukur.

### links variable

#### Melakukan pengecekan tipe data dan banyak kolom
"""

links.info()

"""**Insight**:

* Berdasarkan hasil pengecekan maka dapat diketahui movieId dan imdbId bertipe data int64, tmdbId bertipe float64. Serta tercatat terdapat 3 kolom dalam variabel ini.

#### Melakukan pengecekan 5 data pertama
"""

links.head()

"""**Insight**:

* Dari 5 data pertama yang terlihat, tidak terdapat duplikat values.

#### Melihat summary statistics
"""

links.describe(include='all')

"""**Insight**:

* Terdapat movieId yang tercatat sebanyak 9742 data, dengan nilai minimal 1 dan max 193609.
* Terdapat imdbId yang tercatat sebanyak 9742.
* Terdapat tmdbId yang tercatat sebanyak 9734.

#### Melakukan pengecekan missing values dan duplikat
"""

links.isna().sum()

links.duplicated().sum()

"""**Insight**:

* Terdapat missing values dalam data tmdbId sebanyak 8 dan tidak terdapat duplikat value yang tercatat.

### visualization of movie ids and the num of users voted
"""

no_user_voted = ratings.groupby('movieId')['rating'].agg('count')
no_movies_voted = ratings.groupby('userId')['rating'].agg('count')

plt.style.use('ggplot')
fig, axes = plt.subplots(1, 1, figsize=(16, 4))
plt.scatter(no_user_voted.index, no_user_voted, color='hotpink')
plt.axhline(y=10, color='green')
plt.xlabel('MovieId')
plt.ylabel('No of users voted')
plt.show()

"""**Insight**:

* Visualisasi jumlah user yang memberikan rating terhadap setiap movie ID (movie\_ids vs. users voted) memperlihatkan id film mana yang paling sering dinilai oleh pengguna. Ini membantu mengidentifikasi film populer, yang bisa menjadi titik awal dalam sistem rekomendasi kolaboratif. Kemudian, jika film tertentu memiliki jumlah rating yang jauh lebih rendah, mungkin perlu dilakukan eksposur tambahan atau evaluasi terhadap relevansinya dengan audiens.

# Data Preparation

## Convert data type
"""

tags.timestamp = pd.to_datetime(tags.timestamp, unit='s')
ratings.timestamp = pd.to_datetime(ratings.timestamp, unit='s')

"""## Make title to be lowercase"""

movies['title'] = movies.title.str.lower()

"""## Clean year of the movie from titles"""

movies['title'] = movies['title'].str.replace(r'\(\d{4}\)', '', regex=True).str.strip()
movies['title'] = movies['title'].str.replace(r'\(\d{4}(â€“\d{4})?\)', '', regex=True).str.strip()

"""## Clean genres from separator -> `|`"""

movies['genres'] = movies['genres'].str.replace(r"[\[\]']", "", regex=True).str.replace("|", " ")

"""## Concate title and genre"""

movies['title_genre'] = movies['title'] + ' ' + movies['genres']

"""## Drop duplicates and null values if it's exist in choosen variable for modeling

In this case, i use movies and ratings variable.
"""

# movies
if movies.isna().sum().any():
    print('Ditemukan nilai null, menghapus baris yang mengandung null...')
    movies.dropna(inplace=True)

if movies.duplicated().any():
    print('Ditemukan data duplikat, menghapus duplikat...')
    movies.drop_duplicates(inplace=True)

# ratings
if ratings.isna().sum().any():
    print('Ditemukan nilai null, menghapus baris yang mengandung null...')
    ratings.dropna(inplace=True)

if ratings.duplicated().any():
    print('Ditemukan data duplikat, menghapus duplikat...')
    ratings.drop_duplicates(inplace=True)

print('Data telah bersih dari null dan duplikat.')

"""## Vectorize title_genre"""

tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(movies['title_genre'])

"""## Encode user and item for collaborative filtering"""

user_enc = LabelEncoder()
item_enc = LabelEncoder()
ratings['user'] = user_enc.fit_transform(ratings['userId'])
ratings['item'] = item_enc.fit_transform(ratings['movieId'])

"""## Split data for collaborative filtering"""

train_df, test_df = train_test_split(ratings, test_size=0.4, random_state=42)

"""# Modeling

## Content Based Filtering

### Calculate cosine similarity
"""

cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

"""### Top-k recommendation"""

indices = pd.Series(movies.index, index=movies['title'])
def content_based_recommendations(title, cosine_sim=cosine_sim):
    title = title.lower()
    idx = indices[title]

    sim_scores = cosine_sim[idx]
    if hasattr(sim_scores, "toarray"):  # untuk sparse matrix
        sim_scores = sim_scores.toarray().flatten()
    else:
        sim_scores = sim_scores.flatten()

    sim_scores = list(enumerate(sim_scores))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    sim_scores = sim_scores[1:11]
    movie_indices = [i[0] for i in sim_scores]

    return movies[['title', 'genres']].iloc[movie_indices]

content_based_recommendations('MONSTER')

content_based_recommendations('toy story')

content_based_recommendations('iron SoldiEr')

"""## Collaborative Filtering

### Build Interaction Matrices
"""

def build_interaction_matrix(df, user_col, item_col, rating_col, num_users, num_items):
    # use the total number of unique users and items from the original dataset
    # for the shape of the matrix.
    return coo_matrix(
        (df[rating_col], (df[user_col], df[item_col])),
        shape=(num_users, num_items)
    )

# get the total number of unique users and items from the fitted encoders
num_total_users = len(user_enc.classes_)
num_total_items = len(item_enc.classes_)

# build the interaction matrices using the total number of users and items
train_interaction = build_interaction_matrix(train_df, 'user', 'item', 'rating', num_total_users, num_total_items)
test_interaction = build_interaction_matrix(test_df, 'user', 'item', 'rating', num_total_users, num_total_items)

model = LightFM(loss='warp')
model.fit(train_interaction, epochs=50, num_threads=2)

"""### Top-k recommendation"""

def recommend_items(model, interaction_matrix, user_id, item_labels, movies_df, n=3):
    """
    Memberikan rekomendasi top-N item untuk user tertentu menggunakan model collaborative filtering.

    Parameters:
    - model: LightFM trained model
    - interaction_matrix: sparse matrix interaksi user-item
    - user_id: index user yang ingin diberi rekomendasi (bukan original userId, tapi hasil encoding)
    - item_labels: LabelEncoder untuk item/movieId
    - movies_df: DataFrame yang berisi movieId dan title
    - n: jumlah rekomendasi yang ingin ditampilkan

    Returns:
    - List judul film yang direkomendasikan
    """

    n_items = interaction_matrix.shape[1]
    scores = model.predict(user_id, np.arange(n_items))  # prediction score for all items
    top_items = np.argsort(-scores)[:n]  # take highest score

    recommendation_results = []
    for i in top_items:
        movie_id = item_labels.inverse_transform([i])[0]  # take the movieId
        movie_title = movies_df[movies_df['movieId'] == movie_id]['title'].values[0]
        recommendation_results.append(movie_title)
    return recommendation_results

print(f'Top 10 recommendations for User Index 2:\n')
movies_titles = recommend_items(model, train_interaction, user_id=2, item_labels=item_enc, movies_df=movies, n=10)
for i in range(len(movies_titles)):
  print(movies_titles[i])

print(f'Top 10 recommendations for User Index 5:\n')
movies_titles = recommend_items(model, train_interaction, user_id=5, item_labels=item_enc, movies_df=movies, n=10)
for i in range(len(movies_titles)):
  print(movies_titles[i])

"""# Evaluation

## Evaluate content based filtering
"""

def precision_recall_content_based(input_movie, recommended_movies, k=10):
    input_movie = input_movie.lower()
    input_tfidf = tfidf.transform([input_movie])
    rec_tfidf = tfidf.transform(recommended_movies)

    # calculate cosine similarity between input and recommendations
    sim_scores = cosine_similarity(input_tfidf, rec_tfidf)[0]

    # precision and recall
    precision = sum(sim_scores[:k]) / k
    recall = sum(sim_scores[:k]) / sum(sim_scores) if sum(sim_scores) > 0 else 0
    return precision, recall

input_movies = ['toy story', 'grumpier old men']
recommendation_results = {movie: list(content_based_recommendations(movie)['title']) for movie in input_movies}
for movie in input_movies:
    recommended_titles = recommendation_results[movie]
    precision, recall = precision_recall_content_based(movie, recommended_titles)
    print(f"Precision@10 for '{movie}': {precision:.2f}")
    print(f"Recall@10 for '{movie}': {recall:.2f}")

"""## Evaluate collaborative based filtering"""

train_precision = precision_at_k(model, train_interaction, k=10).mean()
test_precision = precision_at_k(model, test_interaction, k=10).mean()
train_auc = auc_score(model, train_interaction).mean()
test_auc = auc_score(model, test_interaction).mean()
print(f"Train Precision@10: {train_precision:.4f}")
print(f"Test Precision@10: {test_precision:.4f}")
print(f"Train AUC: {train_auc:.4f}")
print(f"Test AUC: {test_auc:.4f}")